# Техническое задание проекта №4

Как человек обычно делает покупки? Если ему нужен не один продукт, а несколько, то очень вероятно, что сначала он составит список, чтобы ничего не забыть. Сделать это можно где угодно: на листе бумаги, в приложении для заметок или, например, в сообщении самому себе в мессенджере.  
А теперь представьте, что это список не продуктов, а полноценных дел. И не каких-нибудь простых вроде «помыть посуду» или «позвонить бабушке», а сложных — например, «организовать большой семейный праздник» или «купить квартиру». Каждая из таких задач может разбиваться на несколько этапов со своими нюансами и сроками. А если над их выполнением будет работать не один человек, а целая команда, то организация процесса станет ещё сложнее.

## Трекер задач

Как системы контроля версий помогают команде работать с общим кодом, так и трекеры задач позволяют эффективно организовать совместную работу над задачами. Вам предстоит написать бэкенд для такого трекера. В итоге должна получиться программа, отвечающая за формирование модели данных для этой страницы:

![Трекер задач](https://github.com/SkvortsovEvg/yandex_final_04/blob/master/image/readme/pic_001.png "Текст 001")

Пользователь не будет видеть консоль вашего приложения. Поэтому нужно сделать так, чтобы методы не просто печатали что-то в консоль, но и возвращали объекты нужных типов.  
Вы можете добавить консольный вывод для самопроверки в класcе Main, но на работу методов он влиять не должен.

## Типы задач

Простейший кирпичик трекера — **задача** (англ. _task_). У неё есть следующие свойства:

1. Название, кратко описывающее суть задачи (например, «Переезд»).

2. Описание, в котором раскрываются детали.

3. Уникальный идентификационный номер задачи, по которому её можно будет найти.

4. Статус, отображающий её прогресс. Вы будете выделять следующие этапы жизни задачи, используя _**enum**_:

* _**NEW**_ — задача только создана, но к её выполнению ещё не приступили.
* _**IN_PROGRESS**_ — над задачей ведётся работа.
* _**DONE**_ — задача выполнена.

Иногда для выполнения какой-нибудь масштабной задачи её лучше разбить на **подзадачи** (англ. _subtask_). Большая задача, которая делится на подзадачи, называется **эпиком** (англ. _epic_).

Подытожим. В системе задачи могут быть трёх типов: обычные задачи, эпики и подзадачи. Для них должны выполняться следующие условия:

* Для каждой подзадачи известно, в рамках какого эпика она выполняется.

* Каждый эпик знает, какие подзадачи в него входят.

* Завершение всех подзадач эпика считается завершением эпика.

### Подсказка: как организовать классы для хранения задач.

У одной и той же проблемы в программировании может быть несколько решений. К примеру, вам нужно представить в программе три вида связанных сущностей: задачи, подзадачи и эпики. Вы можете завести один абстрактный класс и связать три других с ним. Или создать один не абстрактный класс и двух его наследников. Или сделать три отдельных класса.  
Задача программиста — не только сделать выбор, но и обосновать его. Вне зависимости от того, по какому пути вы решите пойти, каждое из этих решений будет лучше в одних ситуациях и хуже в других. 
Для эталонного решения мы выбрали создание публичного не абстрактного класса _Task_, который представляет отдельно стоящую задачу. Его данные наследуют подклассы _Subtask_ и _Epic_.  
В нашем задании класс _Task_ можно использовать сам по себе, не делая его абстрактным. Для подклассов _Subtask_ и _Epic_ наследуем сразу имплементацию, поскольку нам понадобится такое расширение функциональности, которое совместимо с базовым классом и не отличается от него по поведению.

## Идентификатор задачи

В трекере у каждого типа задач есть идентификатор. Это целое число, уникальное для всех типов задач. По нему находят, обновляют, удаляют задачи. При создании задачи менеджер присваивает ей новый идентификатор.

Также советуем применить знания о методах _**equals()**_ и _**hashCode()**_, чтобы реализовать идентификацию задачи по её _**id**_.  При этом две задачи с одинаковым _**id**_ должны выглядеть для менеджера как одна и та же.  
_Эти методы нежелательно переопределять в наследниках. Ваша задача — подумать, почему._

### Подсказка: как создавать идентификаторы.

Для генерации идентификаторов можно использовать числовое поле-счётчик внутри класса _**TaskManager**_, увеличивая его на _**1**_, когда нужно получить новое значение.

## Менеджер

Кроме классов для описания задач, вам нужно реализовать класс для объекта-менеджера. Он будет запускаться на старте программы и управлять всеми задачами. В нём должны быть реализованы следующие функции:

1. Возможность хранить задачи всех типов. Для этого вам нужно выбрать подходящую коллекцию.

2. Методы для каждого из типа задач (Задача/Эпик/Подзадача):

 * Получение списка всех задач.
 
 * Удаление всех задач.
 
 * Получение по идентификатору.
 
 * Создание. Сам объект должен передаваться в качестве параметра.
 
 * Обновление. Новая версия объекта с верным идентификатором передаётся в виде параметра.
 
 * Удаление по идентификатору.

3. Дополнительные методы:

 * Получение списка всех подзадач определённого эпика.

4. Управление статусами осуществляется по следующему правилу:

 * Менеджер сам не выбирает статус для задачи. Информация о нём приходит менеджеру вместе с информацией о самой задаче. По этим данным в одних случаях он будет сохранять статус, в других будет рассчитывать.

 2. Для эпиков:

  * если у эпика нет подзадач или все они имеют статус _**NEW**_, то статус должен быть _**NEW**_.

  * если все подзадачи имеют статус _**DONE**_, то и эпик считается завершённым — со статусом _**DONE**_.

  * во всех остальных случаях статус должен быть _**IN_PROGRESS**_.

## Подсказки

### Хранение задач

Для хранения задач вам нужно:

1. получать задачи по идентификатору;

2. выводить списки задач разных типов.

Один из способов организовать такое хранение — это присвоить соответствие между идентификатором и задачей при помощи **HashMap**. Поскольку идентификатор не может повторяться (иначе он не был бы идентификатором), такой подход позволит быстро получать задачу.  
Чтобы получать разные типы задач, вы можете создать три структуры **HashMap**: по одной на каждый из видов задач.

### Обновление данных

При обновлении данных можете считать, что на вход подаётся новый объект, который должен полностью заменить старый. К примеру, метод для обновления эпика может принимать эпик в качестве входных данных _**public void updateTask(Task task)**_. Если вы храните эпики в **HashMap**, где ключами являются идентификаторы, то обновление — это запись нового эпика _**tasks.put(task.getId(), task))**_.

### Обновление статуса задачи

Фраза «информация приходит вместе с информацией по задаче» означает, что не существует отдельного метода, который занимался бы только обновлением статуса задачи. Вместо этого статус задачи обновляется вместе с полным обновлением задачи.

### Обновление эпиков

Из описания задачи видно, что эпик не управляет своим статусом самостоятельно. Это значит:

1. Пользователь не должен иметь возможности поменять статус эпика самостоятельно.

2. Когда меняется статус любой подзадачи в эпике, вам необходимо проверить, что статус эпика изменится соответствующим образом. При этом изменение статуса эпика может и не произойти, если в нём, к примеру, всё ещё есть незакрытые задачи.

## И ещё кое-что...

* Проверка кода называется тестированием. Подробно вы изучите эту тему дальше в курсе. Тем не менее, сам процесс тестирования можно начать уже сейчас. Создайте в классе _Main_ метод _**static void main(String[] args)**_ и внутри него:

 * Создайте две задачи, а также эпик с двумя подзадачами и эпик с одной подзадачей.
 
 * Распечатайте списки эпиков, задач и подзадач через System.out.println(..).

 * Измените статусы созданных объектов, распечатайте их. Проверьте, что статус задачи и подзадачи сохранился, а статус эпика рассчитался по статусам подзадач.
 
 * И, наконец, попробуйте удалить одну из задач и один из эпиков.

 * Воспользуйтесь дебаггером среды разработки, чтобы понять логику работы программы и отладить её.

* Не оставляйте в коде мусор — превращённые в комментарии или ненужные куски кода. Это сквозной проект, на его основе вы будете делать **несколько следующих домашних заданий**.

* Давайте коммитам осмысленные комментарии: порядок в репозитории и коде — ключ к успеху написания хороших программ.

## Перед тем как приступить к задаче ответьте себе на вопросы:

* Как распределяется функциональность приложения между классами?

* Как классы должны взаимодействовать друг с другом ?

* Как применить принципы ООП и построить систему наследования?

* Какой способ выбрать для хранения задач?

* Должен ли быть у приложения интерфейс?

Интересного вам программирования!